{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-484d3d7d3867f6125ea75d00121aa9811397c475",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/VaultLending.sol": "project/contracts/VaultLending.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/VaultLending.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\ninterface IAccessControlModule {\r\n    function isAdmin(address account) external view returns (bool);\r\n    function isCreditOfficer(address account) external view returns (bool);\r\n}\r\n\r\n\r\ncontract VaultLending {\r\n\r\n    struct Loan {\r\n        bytes32 ref;\r\n        address borrower;\r\n        address token;\r\n        address merchant;\r\n        uint256 principal;\r\n        uint256 outstanding;     // principal + remaining fee\r\n        uint256 startedAt;\r\n        uint256 installmentsPaid;\r\n        uint256 fee;             // remaining fee\r\n        uint256 totalPaid;       // total repaid (principal + fee)\r\n        bool active;\r\n    }\r\n\r\n     // ====== Timelock ======\r\n    struct Timelock {\r\n        uint256 amount;\r\n        address token;      // address(0) for ETH\r\n        address to;\r\n        uint256 unlockTime;\r\n        bool executed;\r\n    }\r\n\r\n\r\n    uint256 private nextLoanId = 1;\r\n     IAccessControlModule public immutable accessControl;\r\n    bool public paused;\r\n    uint256 private _locked;\r\n\r\n    // Loan tracking\r\n    mapping(bytes32 => Loan) public loans;\r\n    mapping(address => bytes32[]) private borrowerLoans;\r\n    mapping(bytes32 => uint256) private loanIndex;\r\n\r\n    // Vault & pool tracking\r\n    mapping(address => mapping(address => uint256)) public vault;            // vault[user][token]\r\n    mapping(address => mapping(address => uint256)) public lenderContribution; // lender[token]\r\n    mapping(address => uint256) public totalPoolContribution;               // total principal per token\r\n    mapping(address => uint256) public pool;                                // total liquidity including fees\r\n\r\n    // Fee tracking (optimized)\r\n    mapping(address => uint256) public cumulativeFeePerToken;               // accumulated fee per 1 token deposited\r\n    mapping(address => mapping(address => uint256)) public feeDebt;         // lender[token] = claimed portion\r\n    uint256 constant FEE_PRECISION = 1e18;\r\n\r\n    // Borrower & lender tracking\r\n    mapping(address => bool) private isBorrower;\r\n    address[] private borrowers;\r\n\r\n    mapping(address => bool) private isLender;\r\n    address[] private lenders;\r\n\r\n    // Events\r\n    event Deposit(address indexed user, address indexed token, uint256 amount);\r\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\r\n    event LoanCreated(bytes32 loanId, address borrower, uint256 principal, uint256 fee);\r\n    event LoanDisbursed(bytes32 loanId, address borrower, uint256 amount);\r\n    event LoanRepaid(bytes32 loanId, address borrower, uint256 amount, uint256 feePaid);\r\n    event LoanClosed(bytes32 loanId, address borrower);\r\n    event FeesWithdrawn(address indexed lender, address indexed token, uint256 amount);\r\n\r\n    event Paused();\r\n    event Unpaused();\r\n    event Whitelisted(address indexed user, bool status);\r\n    event Blacklisted(address indexed user, bool status);\r\n  \r\n    event TimelockCreated(bytes32 indexed id, address token, address to, uint256 amount, uint256 unlockTime);\r\n    event TimelockExecuted(bytes32 indexed id);\r\n\r\n    mapping(address => bool) public whitelist;\r\n    mapping(address => bool) public blacklist;\r\n\r\n\r\n    constructor(address _accessControl) {\r\n        require(_accessControl != address(0), \"Invalid access control\");\r\n        accessControl = IAccessControlModule(_accessControl);\r\n        _locked = 1;\r\n    }\r\n\r\n    // ====== Reentrancy Guard ======\r\n    modifier nonReentrant() {\r\n        require(_locked == 1, \"ReentrancyGuard: reentrant call\");\r\n        _locked = 2;\r\n        _;\r\n        _locked = 1;\r\n    }\r\n\r\n    // ====== Modifiers ======\r\n    modifier onlyAdmin() {\r\n        require(accessControl.isAdmin(msg.sender), \"Only admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCreditOfficer() {\r\n        require(accessControl.isCreditOfficer(msg.sender), \"Only credit officer\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted(address user) {\r\n        require(whitelist[user], \"User not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    modifier notBlacklisted(address user) {\r\n        require(!blacklist[user], \"User is blacklisted\");\r\n        _;\r\n    }\r\n\r\n    modifier loanExists(bytes32 ref) {\r\n        require(loans[ref].borrower != address(0), \"Loan does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n\r\n    // ====== Admin: Whitelist / Blacklist ======\r\n    function setWhitelist(address user, bool status) external onlyAdmin {\r\n        whitelist[user] = status;\r\n        emit Whitelisted(user, status);\r\n    }\r\n\r\n    function setBlacklist(address user, bool status) external onlyAdmin {\r\n        blacklist[user] = status;\r\n        emit Blacklisted(user, status);\r\n    }\r\n\r\n    // ====== Admin: Pause / Unpause ======\r\n    function pause() external onlyAdmin {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    function unpause() external onlyAdmin {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n\r\n    /* ========== VAULT FUNCTIONS ========== */\r\n\r\n    function depositToVault(address token, uint256 amount) external {\r\n        require(amount > 0, \"Amount must be > 0\");\r\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n\r\n        // Update lender fee debt before increasing contribution\r\n        feeDebt[msg.sender][token] += (amount * cumulativeFeePerToken[token]) / FEE_PRECISION;\r\n\r\n        vault[msg.sender][token] += amount;\r\n        lenderContribution[msg.sender][token] += amount;\r\n        totalPoolContribution[token] += amount;\r\n        pool[token] += amount;\r\n\r\n        if (!isLender[msg.sender]) {\r\n            lenders.push(msg.sender);\r\n            isLender[msg.sender] = true;\r\n        }\r\n\r\n        emit Deposit(msg.sender, token, amount);\r\n    }\r\n\r\n    function withdrawFromVault(address token, uint256 amount) external \r\n    whenNotPaused notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        require(vault[msg.sender][token] >= amount, \"Insufficient vault balance\");\r\n\r\n        // Update lender contribution and pool\r\n        vault[msg.sender][token] -= amount;\r\n        if (lenderContribution[msg.sender][token] >= amount) {\r\n            lenderContribution[msg.sender][token] -= amount;\r\n            totalPoolContribution[token] -= amount;\r\n            pool[token] -= amount;\r\n        }\r\n\r\n         IERC20 tokenA = IERC20(token);\r\n        //IERC20(token).transfer(msg.sender, amount);\r\n        // Safe transfer with inline revert check\r\n            (bool success, bytes memory data) = address(tokenA).call(\r\n                abi.encodeWithSelector(tokenA.transfer.selector, msg.sender, amount)\r\n            );\r\n\r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    /* ========== LOAN FUNCTIONS ========== */\r\n\r\n    function createLoan(bytes32 ref,address token, address merchant, uint256 principal, uint256 fee)\r\n     external onlyCreditOfficer {\r\n        require(pool[token] >= principal, \"Insufficient pool liquidity\");\r\n\r\n        \r\n        Loan storage l = loans[ref];\r\n        l.ref = ref;\r\n        l.borrower = msg.sender;\r\n        l.token = token;\r\n        l.merchant = merchant;\r\n        l.principal = principal;\r\n        l.outstanding = principal + fee;\r\n        l.startedAt = block.timestamp;\r\n        l.installmentsPaid = 0;\r\n        l.fee = fee;\r\n        l.totalPaid = 0;\r\n        l.active = true;\r\n\r\n\r\n        // Track borrower\r\n        loanIndex[ref] = borrowerLoans[msg.sender].length;\r\n        borrowerLoans[msg.sender].push(ref);\r\n        if (!isBorrower[msg.sender]) {\r\n            borrowers.push(msg.sender);\r\n            isBorrower[msg.sender] = true;\r\n        }\r\n\r\n        // Disburse principal to borrower vault\r\n        pool[token] -= principal;\r\n        vault[msg.sender][token] += principal;\r\n\r\n        emit LoanCreated(ref, msg.sender, principal, fee);\r\n        emit LoanDisbursed(ref, msg.sender, principal);\r\n    }\r\n\r\n    function repayLoan(bytes32 ref, uint256 amount) external {\r\n        Loan storage loan = loans[ref];\r\n        require(loan.active, \"Loan is closed\");\r\n        require(loan.borrower == msg.sender, \"Not borrower\");\r\n        require(amount > 0, \"Amount must be > 0\");\r\n\r\n        uint256 remaining = amount;\r\n\r\n        // Use vault balance first\r\n        uint256 vaultBalance = vault[msg.sender][loan.token];\r\n        if (vaultBalance > 0) {\r\n            uint256 fromVault = vaultBalance >= remaining ? remaining : vaultBalance;\r\n            vault[msg.sender][loan.token] -= fromVault;\r\n            remaining -= fromVault;\r\n        }\r\n\r\n        // Use external transfer if needed\r\n        if (remaining > 0) {\r\n            IERC20(loan.token).transferFrom(msg.sender, address(this), remaining);\r\n        }\r\n\r\n        // Allocate fee portion\r\n        uint256 feePaid = loan.fee >= amount ? amount : loan.fee;\r\n        loan.fee -= feePaid;\r\n        _addFeeToPool(loan.token, feePaid);\r\n\r\n        uint256 principalPaid = amount - feePaid;\r\n        if (principalPaid >= loan.outstanding) {\r\n            principalPaid = loan.outstanding - feePaid;\r\n        }\r\n\r\n        loan.outstanding -= (principalPaid + feePaid);\r\n        loan.totalPaid += amount;\r\n\r\n        if (loan.outstanding == 0) {\r\n            loan.active = false;\r\n            _removeLoanFromBorrower(msg.sender, ref);\r\n            emit LoanClosed(ref, msg.sender);\r\n        }\r\n\r\n        emit LoanRepaid(ref, msg.sender, principalPaid + feePaid, feePaid);\r\n    }\r\n\r\n    function _addFeeToPool(address token, uint256 feeAmount) internal {\r\n        if (totalPoolContribution[token] == 0) return;\r\n        cumulativeFeePerToken[token] += (feeAmount * FEE_PRECISION) / totalPoolContribution[token];\r\n        pool[token] += feeAmount;\r\n    }\r\n\r\n    function _removeLoanFromBorrower(address borrower, bytes32 ref) internal {\r\n        uint256 index = loanIndex[ref];\r\n        bytes32 lastRef = borrowerLoans[borrower][borrowerLoans[borrower].length - 1];\r\n\r\n        // Replace the removed ref with the last one\r\n        borrowerLoans[borrower][index] = lastRef;\r\n        loanIndex[lastRef] = index;\r\n\r\n        // Remove last element and delete index mapping\r\n        borrowerLoans[borrower].pop();\r\n        delete loanIndex[ref];\r\n    }\r\n\r\n    /* ========== FEE WITHDRAWAL ========== */\r\n\r\n    function getWithdrawableFees(address lender, address token) public view returns (uint256) {\r\n        uint256 contribution = lenderContribution[lender][token];\r\n        if (contribution == 0) return 0;\r\n\r\n        uint256 accumulatedFee = (contribution * cumulativeFeePerToken[token]) / FEE_PRECISION;\r\n        uint256 withdrawable = accumulatedFee > feeDebt[lender][token] ? accumulatedFee - feeDebt[lender][token] : 0;\r\n        return withdrawable;\r\n    }\r\n\r\n    function withdrawFees(address token) external {\r\n        uint256 amount = getWithdrawableFees(msg.sender, token);\r\n        require(amount > 0, \"No fees to withdraw\");\r\n\r\n        feeDebt[msg.sender][token] += amount;\r\n        pool[token] -= amount;\r\n\r\n        IERC20(token).transfer(msg.sender, amount);\r\n        emit FeesWithdrawn(msg.sender, token, amount);\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    function getBorrowerStats(address borrower, address token) \r\n        external \r\n        view \r\n        returns (uint256 vaultBalance, uint256 totalPaidToPool) \r\n    {\r\n        vaultBalance = vault[borrower][token];\r\n        totalPaidToPool = 0;\r\n\r\n        bytes32[] memory refs = borrowerLoans[borrower];\r\n        for (uint256 i = 0; i < refs.length; i++) {\r\n            Loan storage loan = loans[refs[i]];\r\n            if (loan.token == token) {\r\n                totalPaidToPool += loan.totalPaid;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getLenderStats(address lender, address token) \r\n        external \r\n        view \r\n        returns (\r\n            uint256 deposit,\r\n            uint256 poolShare,\r\n            uint256 totalFeesEarned,\r\n            uint256 feesClaimed\r\n        ) \r\n    {\r\n        deposit = vault[lender][token];\r\n        feesClaimed = feeDebt[lender][token];\r\n\r\n        uint256 contribution = lenderContribution[lender][token];\r\n        uint256 totalAccumulatedFee = (contribution * cumulativeFeePerToken[token]) / FEE_PRECISION;\r\n        totalFeesEarned = totalAccumulatedFee;\r\n        poolShare = deposit + (totalFeesEarned - feesClaimed);\r\n    }\r\n\r\n    function getProtocolStats(address token) \r\n        external \r\n        view \r\n        returns (\r\n            uint256 numLenders,\r\n            uint256 numBorrowers,\r\n            uint256 totalLenderDeposits,\r\n            uint256 totalBorrowed,\r\n            uint256 totalOutstanding,\r\n            uint256 totalPaid\r\n        ) \r\n    {\r\n        numLenders = lenders.length;\r\n        totalLenderDeposits = 0;\r\n        for (uint256 i = 0; i < lenders.length; i++) {\r\n            totalLenderDeposits += vault[lenders[i]][token];\r\n        }\r\n\r\n        numBorrowers = borrowers.length;\r\n        totalBorrowed = 0;\r\n        totalOutstanding = 0;\r\n        totalPaid = 0;\r\n        for (uint256 i = 0; i < borrowers.length; i++) {\r\n            bytes32[] memory ids = borrowerLoans[borrowers[i]];\r\n            for (uint256 j = 0; j < ids.length; j++) {\r\n                Loan storage loan = loans[ids[j]];\r\n                if (loan.token == token) {\r\n                    totalBorrowed += loan.principal;\r\n                    totalOutstanding += loan.outstanding;\r\n                    totalPaid += loan.totalPaid;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAllBorrowers() external view returns (address[] memory) {\r\n        return borrowers;\r\n    }\r\n\r\n    function getAllLenders() external view returns (address[] memory) {\r\n        return lenders;\r\n    }\r\n\r\n    function getLoans(address borrower) external view returns (Loan[] memory) {\r\n        bytes32[] memory ids = borrowerLoans[borrower];\r\n        Loan[] memory result = new Loan[](ids.length);\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            result[i] = loans[ids[i]];\r\n        }\r\n        return result;\r\n    }\r\n}"
      }
    }
  }
}