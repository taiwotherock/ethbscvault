{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-323cfe5acc179a438d291790033872a1abbd260c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/TradeEscrowVault.sol": "project/contracts/TradeEscrowVault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/TradeEscrowVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\ninterface IAccessControlModule {\r\n    function isAdmin(address account) external view returns (bool);\r\n}\r\n\r\ncontract TradeEscrowVault {\r\n   \r\n    \r\n    event OfferCancelled(bytes32 indexed ref);\r\n    event OfferMarkedPaid(bytes32 indexed ref);\r\n    event OfferPicked(bytes32 indexed ref, uint256 tokenAmount);\r\n    event OfferReleased(bytes32 indexed ref);\r\n    event AppealCreated(bytes32 indexed ref, address indexed caller);\r\n    event AppealResolved(bytes32 indexed ref, bool released);\r\n    event Paused();\r\n    event Unpaused();\r\n    event Whitelisted(address indexed user, bool status);\r\n    event Blacklisted(address indexed user, bool status);\r\n    event OfferCreated(\r\n        bytes32 indexed ref,\r\n        address indexed creator,\r\n        address indexed counterparty,\r\n        uint256 tokenAmount,\r\n        address token,\r\n        bool isBuy,\r\n        uint32 expiry,\r\n        bytes3 fiatSymbol,\r\n        uint64 fiatAmount,\r\n        uint64 fiatToTokenRate\r\n    );\r\n    \r\n    event TimelockCreated(bytes32 indexed id, address token, address to, uint256 amount, uint256 unlockTime);\r\n    event TimelockExecuted(bytes32 indexed id);\r\n\r\n    event Debug(\r\n    string stage,\r\n    bytes32 ref,\r\n    address creator,\r\n    address counterparty,\r\n    address token,\r\n    bool isBuy,\r\n    uint256 tokenAmount,\r\n    uint256 fiatAmount,\r\n    uint256 fiatToTokenRate\r\n);\r\n\r\nevent DebugBalance(string info, address token, uint256 balance);\r\nevent DebugTransfer(string info, address token, address to, uint256 amount);\r\nevent DebugTransferFail(string info, string reason);\r\nevent DebugTransferFailBytes(string info, bytes data);\r\nevent DebugMessage(string info);\r\n\r\n\r\n    // ====== Config ======\r\n    IAccessControlModule public immutable accessControl;\r\n    bool public paused;\r\n    uint256 private _locked;\r\n    uint256 constant DECIMALS = 1e18;\r\n\r\n    mapping(bytes32 => Timelock) public timelocks;\r\n    uint256 public constant TIMELOCK_DELAY = 1 days; // configurable delay\r\n\r\n    constructor(address _accessControl) {\r\n        require(_accessControl != address(0), \"Invalid access control\");\r\n        accessControl = IAccessControlModule(_accessControl);\r\n        _locked = 1;\r\n    }\r\n\r\n    // ====== Reentrancy Guard ======\r\n    modifier nonReentrant() {\r\n        require(_locked == 1, \"ReentrancyGuard: reentrant call\");\r\n        _locked = 2;\r\n        _;\r\n        _locked = 1;\r\n    }\r\n\r\n    // ====== Structs ======\r\n    struct Offer {\r\n        address creator;\r\n        address counterparty;\r\n        address token;\r\n        bool isBuy;\r\n        bool paid;\r\n        bool released;\r\n        bool picked;\r\n        uint32 expiry;       // fits in 4 bytes instead of 32\r\n        uint64 fiatAmount;   // 8 bytes, adjust max as needed\r\n        uint64 fiatToTokenRate; // 8 bytes, scaled by 1e18\r\n        bytes3 fiatSymbol;   // store as 3 bytes like \"USD\", \"NGN\"\r\n        bool appealed;\r\n        uint64 tokenAmount;\r\n    }\r\n\r\n    // ====== Timelock ======\r\n    struct Timelock {\r\n        uint256 amount;\r\n        address token;      // address(0) for ETH\r\n        address to;\r\n        uint256 unlockTime;\r\n        bool executed;\r\n    }\r\n\r\n\r\n    mapping(bytes32 => Offer) public offers;\r\n    mapping(address => bool) public whitelist;\r\n    mapping(address => bool) public blacklist;\r\n\r\n    // ====== Modifiers ======\r\n    modifier onlyAdmin() {\r\n        require(accessControl.isAdmin(msg.sender), \"Only admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted(address user) {\r\n        require(whitelist[user], \"User not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    modifier notBlacklisted(address user) {\r\n        require(!blacklist[user], \"User is blacklisted\");\r\n        _;\r\n    }\r\n\r\n    modifier offerExists(bytes32 ref) {\r\n        require(offers[ref].creator != address(0), \"Offer does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n\r\n    // ====== Admin: Whitelist / Blacklist ======\r\n    function setWhitelist(address user, bool status) external onlyAdmin {\r\n        whitelist[user] = status;\r\n        emit Whitelisted(user, status);\r\n    }\r\n\r\n    function setBlacklist(address user, bool status) external onlyAdmin {\r\n        blacklist[user] = status;\r\n        emit Blacklisted(user, status);\r\n    }\r\n\r\n    // ====== Admin: Pause / Unpause ======\r\n    function pause() external onlyAdmin {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    function unpause() external onlyAdmin {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n\r\n    // ====== Internal: Safe ERC20 transfer ======\r\n    /*function _safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        require(token.transfer(to, amount), \"ERC20 transfer failed\");\r\n    }\r\n\r\n    function _safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        require(token.transferFrom(from, to, amount), \"ERC20 transferFrom failed\");\r\n    }*/\r\n\r\n    function _safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            address(token).call(abi.encodeWithSelector(token.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeTransfer: failed\");\r\n    }\r\n\r\n    function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            address(token).call(abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeTransferFrom: failed\");\r\n    }\r\n\r\n     // --- HELPER CHECKS ---\r\n\r\n    function _checkAllowanceAndBalance(IERC20 token, address user, uint256 requiredAmount) internal view {\r\n        uint256 balance = token.balanceOf(user);\r\n        require(balance >= requiredAmount, \"Insufficient balance\");\r\n\r\n        uint256 allowance = token.allowance(user, address(this));\r\n        require(allowance >= requiredAmount, \"Insufficient allowance\");\r\n    }\r\n\r\n    // ====== Offer Management ======\r\n    function createOffer(\r\n        bytes32 ref,\r\n        address counterparty,\r\n        address token,\r\n        bool isBuy,\r\n        uint32 expiry,\r\n        string calldata fiatSymbol,\r\n        uint64 fiatAmount,\r\n        uint64 fiatToTokenRate,\r\n        uint64 tokenAmount\r\n    ) external whenNotPaused notBlacklisted(msg.sender) notBlacklisted(counterparty) onlyWhitelisted(msg.sender) {\r\n        require(ref != bytes32(0), \"Invalid ref\");\r\n        require(offers[ref].creator == address(0), \"Offer exists\");\r\n        //require(counterparty != address(0), \"Invalid counterparty\");\r\n        require(expiry > block.timestamp, \"Expiry must be future\");\r\n        require(fiatToTokenRate > 0, \"Invalid rate\");\r\n        require(bytes(fiatSymbol).length == 3, \"Fiat symbol must be 3 chars\");\r\n        require(fiatAmount > 0, \"Invalid fiat amount\");\r\n        require(fiatToTokenRate > 0, \"Invalid token rate\");\r\n        require(tokenAmount > 0, \"Invalid token amount\");\r\n\r\n        // Compute tokenAmount using fixed-point arithmetic (DECIMALS = 1e18)\r\n      \r\n\r\n        // Convert fiatSymbol string (3 chars) to bytes3\r\n        bytes3 symbol;\r\n        assembly {\r\n            // calldata layout: fiatSymbol is a dynamic calldata item; fiatSymbol.offset points to its location\r\n            // load 32 bytes from the string location then truncate to bytes3\r\n            symbol := calldataload(fiatSymbol.offset)\r\n        }\r\n\r\n        IERC20 erc20 = IERC20(token);\r\n\r\n        // âœ… Check allowance and balance before transfer\r\n        _checkAllowanceAndBalance(erc20, msg.sender, tokenAmount);\r\n\r\n        // Delegate storage writes, transfer and event emission to an internal function\r\n        _saveOfferAndTransfer(\r\n            ref,\r\n            msg.sender,\r\n            counterparty,\r\n            token,\r\n            isBuy,\r\n            expiry,\r\n            symbol,\r\n            fiatAmount,\r\n            fiatToTokenRate,\r\n            tokenAmount\r\n        );\r\n    }\r\n\r\n    function _saveOfferAndTransfer(\r\n        bytes32 ref,\r\n        address creator,\r\n        address counterparty,\r\n        address token,\r\n        bool isBuy,\r\n        uint32 expiry,\r\n        bytes3 fiatSymbol,\r\n        uint64 fiatAmount,\r\n        uint64 fiatToTokenRate,\r\n        uint64 tokenAmount\r\n    ) internal {\r\n        // Write into storage (single storage pointer usage)\r\n\r\n         // Transfer tokens to escrow for seller offers (do this after storage write)\r\n        if (!isBuy && tokenAmount > 0) {\r\n            _safeTransferFrom(IERC20(token), creator, address(this), tokenAmount);\r\n        }\r\n\r\n        Offer storage o = offers[ref];\r\n        o.creator = creator;\r\n        o.counterparty = counterparty;\r\n        o.token = token;\r\n        o.isBuy = isBuy;\r\n        o.expiry = expiry;\r\n        o.fiatSymbol = fiatSymbol;\r\n        o.fiatAmount = fiatAmount;\r\n        o.fiatToTokenRate = fiatToTokenRate;\r\n        o.appealed = false;\r\n        o.paid = false;\r\n        o.released = false;\r\n        o.picked = false;\r\n        o.tokenAmount = tokenAmount;\r\n\r\n        // Emit event\r\n        emit OfferCreated(\r\n            ref,\r\n            creator,\r\n            counterparty,\r\n            tokenAmount,\r\n            token,\r\n            isBuy,\r\n            expiry,\r\n            fiatSymbol,\r\n            fiatAmount,\r\n            fiatToTokenRate\r\n        );\r\n    }\r\n\r\n    function cancelOffer(bytes32 ref) external offerExists(ref) whenNotPaused nonReentrant notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.creator, \"Only creator\");\r\n        require(!o.released && !o.paid, \"Cannot cancel\");\r\n        require(!o.picked , \"Already picked\");\r\n\r\n        if (!o.isBuy && o.tokenAmount > 0) {\r\n            _safeTransfer(IERC20(o.token), o.creator, o.tokenAmount);\r\n        }\r\n\r\n        delete offers[ref];\r\n        emit OfferCancelled(ref);\r\n    }\r\n\r\n    function markPaid(bytes32 ref) external offerExists(ref) whenNotPaused notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.counterparty, \"Only counterparty\");\r\n        require(o.picked, \"Not picked\");\r\n        require(!o.paid, \"Already marked paid\");\r\n        o.paid = true;\r\n        emit OfferMarkedPaid(ref);\r\n    }\r\n\r\n    function pickOffer(bytes32 ref) external offerExists(ref) whenNotPaused notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.counterparty || o.counterparty == address(0), \"only chosen counterparty\");\r\n        require(!o.paid, \"Already marked paid\");\r\n        require(!o.picked, \"Already picked\");\r\n        require(!o.released, \"Already released\");\r\n\r\n         \r\n        o.counterparty =  msg.sender;\r\n        if (o.isBuy && o.tokenAmount > 0) {\r\n            _safeTransferFrom(IERC20(o.token), msg.sender, address(this), o.tokenAmount);\r\n        }\r\n        o.picked = true;\r\n        \r\n        //if pick for buy USDT, the picker USDT must be transferred to vault\r\n\r\n        emit OfferPicked(ref,o.tokenAmount);\r\n    }\r\n\r\n    function releaseFund(address token1) external onlyAdmin\r\n    {\r\n            IERC20 token = IERC20(token1);\r\n            uint256 bal = token.balanceOf(address(this));\r\n            emit DebugBalance(\"Vault balance before transfer\", token1, bal);\r\n\r\n        \r\n           // Safe transfer with inline revert check\r\n            (bool success, bytes memory data) = address(token).call(\r\n                abi.encodeWithSelector(token.transfer.selector, msg.sender, bal)\r\n            );\r\n\r\n            if(success)\r\n               emit DebugMessage('Success');\r\n            else\r\n              emit DebugMessage('Failed');\r\n\r\n            if (!success) {\r\n                string memory reason = _getRevertMsg(data);\r\n                emit DebugTransferFail(\"Token transfer failed\", reason);\r\n                revert(string(abi.encodePacked(\"transfer failed: \", reason)));\r\n            }\r\n    }\r\n\r\n    function releaseOffer(bytes32 ref) external offerExists(ref)  whenNotPaused nonReentrant {\r\n        Offer storage o = offers[ref];\r\n        require(o.paid, \"Not marked paid\");\r\n        require(!o.released, \"Already released\");\r\n        require(o.picked, \"Not picked\");\r\n        require(whitelist[o.creator] && whitelist[o.counterparty], \"Both must be whitelisted\");\r\n        require(!blacklist[o.creator] && !blacklist[o.counterparty], \"Cannot release to blacklisted user\");\r\n\r\n        if (o.isBuy)\r\n            require(msg.sender == o.counterparty, \"Only seller can release\");\r\n        else \r\n            require(msg.sender == o.creator, \"Only Buyer can release\");\r\n            \r\n       //if is buy USDT true, pick offer, and mark paid, release it\r\n       //if sell usdt, lock into vault, confirm receipt and release\r\n       emit Debug(\"releaseOffer: pre-transfer\", ref, o.creator, o.counterparty, o.token, o.isBuy, o.tokenAmount, o.fiatAmount, o.fiatToTokenRate);\r\n        \r\n        //if (!o.isBuy) {\r\n\r\n             require(o.tokenAmount > 0, \"tokenAmount=0\");\r\n            IERC20 token = IERC20(o.token);\r\n            uint256 bal = token.balanceOf(address(this));\r\n            emit DebugBalance(\"Vault balance before transfer\", o.token, bal);\r\n\r\n            //_safeTransfer(IERC20(o.token), o.counterparty, o.tokenAmount);\r\n            require(bal >= o.tokenAmount, \"insufficient vault balance\");\r\n\r\n           // Safe transfer with inline revert check\r\n            (bool success, bytes memory data) = address(token).call(\r\n                abi.encodeWithSelector(token.transfer.selector, o.counterparty, o.tokenAmount)\r\n            );\r\n\r\n            if (!success) {\r\n                string memory reason = _getRevertMsg(data);\r\n                emit DebugTransferFail(\"Token transfer failed\", reason);\r\n                revert(string(abi.encodePacked(\"transfer failed: \", reason)));\r\n            }\r\n\r\n            emit DebugTransfer(\"Token transfer success\", o.token, o.counterparty, o.tokenAmount);\r\n        //}\r\n\r\n        o.released = true;\r\n        emit OfferReleased(ref);\r\n    }\r\n\r\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\r\n        // If no revert message, return default\r\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\r\n        assembly {\r\n            _returnData := add(_returnData, 0x04)\r\n        }\r\n        return abi.decode(_returnData, (string));\r\n    }\r\n\r\n    // ====== Appeals ======\r\n    function createAppeal(bytes32 ref) external offerExists(ref) whenNotPaused notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.creator || msg.sender == o.counterparty, \"Only parties\");\r\n        require(!o.appealed, \"Already appealed\");\r\n        o.appealed = true;\r\n        emit AppealCreated(ref, msg.sender);\r\n    }\r\n\r\n    function resolveAppeal(bytes32 ref, bool release) external onlyAdmin offerExists(ref) whenNotPaused nonReentrant {\r\n        Offer storage o = offers[ref];\r\n        require(o.appealed, \"No appeal\");\r\n        o.appealed = false;\r\n\r\n        if (release && !o.released) {\r\n            require(whitelist[o.creator] && whitelist[o.counterparty], \"Both must be whitelisted\");\r\n            require(!blacklist[o.creator] && !blacklist[o.counterparty], \"Cannot release to blacklisted user\");\r\n            \r\n            if (!o.isBuy && o.tokenAmount > 0) {\r\n                _safeTransfer(IERC20(o.token), o.counterparty, o.tokenAmount);\r\n            }\r\n            o.released = true;\r\n        }\r\n\r\n        emit AppealResolved(ref, release);\r\n    }\r\n\r\n    // Dedicated getter for offers\r\n        function getOffer(bytes32 ref) external view returns (\r\n            address creator,\r\n            address counterparty,\r\n            address token,\r\n            bool isBuy,\r\n            uint32 expiry,\r\n            bytes3 fiatSymbol,\r\n            uint64 fiatAmount,\r\n            uint64 fiatToTokenRate,\r\n            bool appealed,\r\n            bool paid,\r\n            bool released,\r\n            uint256 tokenAmount\r\n        ) {\r\n            Offer storage o = offers[ref];\r\n             return (\r\n                o.creator,\r\n                o.counterparty,\r\n                o.token,\r\n                o.isBuy,\r\n                o.expiry,\r\n                o.fiatSymbol,\r\n                o.fiatAmount,\r\n                o.fiatToTokenRate,\r\n                o.appealed,\r\n                o.paid,\r\n                o.released,\r\n                o.tokenAmount );\r\n        }\r\n\r\n\r\n        // ====== Admin: schedule rescue ======\r\n        function scheduleRescueERC20(address token, address to, uint256 amount) external onlyAdmin returns (bytes32) {\r\n            require(to != address(0), \"invalid address\");\r\n            uint256 bal = IERC20(token).balanceOf(address(this));\r\n            uint256 send = amount == 0 ? bal : amount;\r\n            require(send <= bal, \"no balance\");\r\n\r\n            bytes32 id = keccak256(abi.encodePacked(token, to, send, block.timestamp));\r\n            timelocks[id] = Timelock(send, token, to, block.timestamp + TIMELOCK_DELAY, false);\r\n            emit TimelockCreated(id, token, to, send, block.timestamp + TIMELOCK_DELAY);\r\n            return id;\r\n        }\r\n\r\n        function executeRescueERC20(bytes32 id) external onlyAdmin {\r\n            Timelock storage t = timelocks[id];\r\n            require(!t.executed, \"already executed\");\r\n            require(block.timestamp >= t.unlockTime, \"timelock not expired\");\r\n\r\n            _safeTransfer(IERC20(t.token), t.to, t.amount);\r\n            t.executed = true;\r\n            emit TimelockExecuted(id);\r\n        }\r\n\r\n        // ====== Admin: schedule rescue ETH ======\r\n        function scheduleRescueETH(address payable to, uint256 amount) external onlyAdmin returns (bytes32) {\r\n            require(to != address(0), \"invalid address\");\r\n            uint256 bal = address(this).balance;\r\n            uint256 send = amount == 0 ? bal : amount;\r\n            require(send <= bal, \"no balance\");\r\n\r\n            bytes32 id = keccak256(abi.encodePacked(address(0), to, send, block.timestamp));\r\n            timelocks[id] = Timelock(send, address(0), to, block.timestamp + TIMELOCK_DELAY, false);\r\n            emit TimelockCreated(id, address(0), to, send, block.timestamp + TIMELOCK_DELAY);\r\n            return id;\r\n        }\r\n\r\n        function executeRescueETH(bytes32 id) external onlyAdmin {\r\n            Timelock storage t = timelocks[id];\r\n            require(!t.executed, \"already executed\");\r\n            require(block.timestamp >= t.unlockTime, \"timelock not expired\");\r\n\r\n            (bool s,) = payable(t.to).call{value: t.amount}(\"\");\r\n            require(s, \"eth transfer failed\");\r\n            t.executed = true;\r\n            emit TimelockExecuted(id);\r\n        }\r\n}"
      }
    }
  }
}