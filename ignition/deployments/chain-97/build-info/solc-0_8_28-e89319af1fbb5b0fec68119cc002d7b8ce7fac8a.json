{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e89319af1fbb5b0fec68119cc002d7b8ce7fac8a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/TradeEscrowVault.sol": "project/contracts/TradeEscrowVault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/TradeEscrowVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IAccessControlModule {\r\n    function isAdmin(address account) external view returns (bool);\r\n}\r\n\r\ncontract TradeEscrowVault {\r\n   \r\n    event OfferCancelled(bytes32 indexed ref);\r\n    event OfferMarkedPaid(bytes32 indexed ref);\r\n    event OfferReleased(bytes32 indexed ref);\r\n    event AppealCreated(bytes32 indexed ref, address indexed caller);\r\n    event AppealResolved(bytes32 indexed ref, bool released);\r\n    event Paused();\r\n    event Unpaused();\r\n    event Whitelisted(address indexed user, bool status);\r\n    event Blacklisted(address indexed user, bool status);\r\n    event OfferCreated(\r\n        bytes32 indexed ref,\r\n        address indexed creator,\r\n        address indexed counterparty,\r\n        uint256 tokenAmount,\r\n        address token,\r\n        bool isBuy,\r\n        uint32 expiry,\r\n        bytes3 fiatSymbol,\r\n        uint64 fiatAmount,\r\n        uint64 fiatToTokenRate\r\n    );\r\n\r\n\r\n    // ====== Config ======\r\n    IAccessControlModule public immutable accessControl;\r\n    bool public paused;\r\n    uint256 private _locked;\r\n    uint256 constant DECIMALS = 1e18;\r\n\r\n    constructor(address _accessControl) {\r\n        require(_accessControl != address(0), \"Invalid access control\");\r\n        accessControl = IAccessControlModule(_accessControl);\r\n        _locked = 1;\r\n    }\r\n\r\n    // ====== Reentrancy Guard ======\r\n    modifier nonReentrant() {\r\n        require(_locked == 1, \"ReentrancyGuard: reentrant call\");\r\n        _locked = 2;\r\n        _;\r\n        _locked = 1;\r\n    }\r\n\r\n    // ====== Structs ======\r\n    struct Offer {\r\n        address creator;\r\n        address counterparty;\r\n        address token;\r\n        bool isBuy;\r\n        bool paid;\r\n        bool released;\r\n        uint32 expiry;       // fits in 4 bytes instead of 32\r\n        uint64 fiatAmount;   // 8 bytes, adjust max as needed\r\n        uint64 fiatToTokenRate; // 8 bytes, scaled by 1e18\r\n        bytes3 fiatSymbol;   // store as 3 bytes like \"USD\", \"NGN\"\r\n        bool appealed;\r\n    }\r\n\r\n\r\n    mapping(bytes32 => Offer) public offers;\r\n    mapping(address => bool) public whitelist;\r\n    mapping(address => bool) public blacklist;\r\n\r\n    // ====== Modifiers ======\r\n    modifier onlyAdmin() {\r\n        require(accessControl.isAdmin(msg.sender), \"Only admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted(address user) {\r\n        require(whitelist[user], \"User not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    modifier notBlacklisted(address user) {\r\n        require(!blacklist[user], \"User is blacklisted\");\r\n        _;\r\n    }\r\n\r\n    modifier offerExists(bytes32 ref) {\r\n        require(offers[ref].creator != address(0), \"Offer does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n\r\n    // ====== Admin: Whitelist / Blacklist ======\r\n    function setWhitelist(address user, bool status) external onlyAdmin {\r\n        whitelist[user] = status;\r\n        emit Whitelisted(user, status);\r\n    }\r\n\r\n    function setBlacklist(address user, bool status) external onlyAdmin {\r\n        blacklist[user] = status;\r\n        emit Blacklisted(user, status);\r\n    }\r\n\r\n    // ====== Admin: Pause / Unpause ======\r\n    function pause() external onlyAdmin {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    function unpause() external onlyAdmin {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n\r\n    // ====== Internal: Safe ERC20 transfer ======\r\n    function _safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        require(token.transfer(to, amount), \"ERC20 transfer failed\");\r\n    }\r\n\r\n    function _safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        require(token.transferFrom(from, to, amount), \"ERC20 transferFrom failed\");\r\n    }\r\n\r\n    // ====== Offer Management ======\r\n    function createOffer(\r\n        bytes32 ref,\r\n        address counterparty,\r\n        address token,\r\n        bool isBuy,\r\n        uint32 expiry,\r\n        string calldata fiatSymbol,\r\n        uint64 fiatAmount,\r\n        uint64 fiatToTokenRate\r\n    ) external whenNotPaused notBlacklisted(msg.sender) notBlacklisted(counterparty) onlyWhitelisted(msg.sender) {\r\n        require(ref != bytes32(0), \"Invalid ref\");\r\n        require(offers[ref].creator == address(0), \"Offer exists\");\r\n        require(counterparty != address(0), \"Invalid counterparty\");\r\n        require(expiry > block.timestamp, \"Expiry must be future\");\r\n        require(fiatToTokenRate > 0, \"Invalid rate\");\r\n        require(bytes(fiatSymbol).length == 3, \"Fiat symbol must be 3 chars\");\r\n\r\n        // Compute tokenAmount using fixed-point arithmetic (DECIMALS = 1e18)\r\n        uint256 tokenAmount = (uint256(fiatAmount) * uint256(fiatToTokenRate)) / DECIMALS;\r\n\r\n        // Convert fiatSymbol string (3 chars) to bytes3\r\n        bytes3 symbol;\r\n        assembly {\r\n            // calldata layout: fiatSymbol is a dynamic calldata item; fiatSymbol.offset points to its location\r\n            // load 32 bytes from the string location then truncate to bytes3\r\n            symbol := calldataload(fiatSymbol.offset)\r\n        }\r\n\r\n        // Delegate storage writes, transfer and event emission to an internal function\r\n        _saveOfferAndTransfer(\r\n            ref,\r\n            msg.sender,\r\n            counterparty,\r\n            token,\r\n            isBuy,\r\n            expiry,\r\n            symbol,\r\n            fiatAmount,\r\n            fiatToTokenRate,\r\n            tokenAmount\r\n        );\r\n    }\r\n\r\n    function _saveOfferAndTransfer(\r\n        bytes32 ref,\r\n        address creator,\r\n        address counterparty,\r\n        address token,\r\n        bool isBuy,\r\n        uint32 expiry,\r\n        bytes3 fiatSymbol,\r\n        uint64 fiatAmount,\r\n        uint64 fiatToTokenRate,\r\n        uint256 tokenAmount\r\n    ) internal {\r\n        // Write into storage (single storage pointer usage)\r\n        Offer storage o = offers[ref];\r\n        o.creator = creator;\r\n        o.counterparty = counterparty;\r\n        o.token = token;\r\n        o.isBuy = isBuy;\r\n        o.expiry = expiry;\r\n        o.fiatSymbol = fiatSymbol;\r\n        o.fiatAmount = fiatAmount;\r\n        o.fiatToTokenRate = fiatToTokenRate;\r\n        o.appealed = false;\r\n        o.paid = false;\r\n        o.released = false;\r\n\r\n        // Transfer tokens to escrow for seller offers (do this after storage write)\r\n        if (!isBuy && tokenAmount > 0) {\r\n            _safeTransferFrom(IERC20(token), creator, address(this), tokenAmount);\r\n        }\r\n\r\n        // Emit event\r\n        emit OfferCreated(\r\n            ref,\r\n            creator,\r\n            counterparty,\r\n            tokenAmount,\r\n            token,\r\n            isBuy,\r\n            expiry,\r\n            fiatSymbol,\r\n            fiatAmount,\r\n            fiatToTokenRate\r\n        );\r\n    }\r\n\r\n    function cancelOffer(bytes32 ref) external offerExists(ref) whenNotPaused nonReentrant notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.creator, \"Only creator\");\r\n        require(!o.released && !o.paid, \"Cannot cancel\");\r\n\r\n        uint256 tokenAmount = (o.fiatAmount * o.fiatToTokenRate) / DECIMALS;\r\n\r\n        if (!o.isBuy && tokenAmount > 0) {\r\n            _safeTransfer(IERC20(o.token), o.creator, tokenAmount);\r\n        }\r\n\r\n        delete offers[ref];\r\n        emit OfferCancelled(ref);\r\n    }\r\n\r\n    function markPaid(bytes32 ref) external offerExists(ref) whenNotPaused notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.counterparty, \"Only counterparty\");\r\n        require(!o.paid, \"Already marked paid\");\r\n        o.paid = true;\r\n        emit OfferMarkedPaid(ref);\r\n    }\r\n\r\n    function releaseOffer(bytes32 ref) external offerExists(ref) onlyAdmin whenNotPaused nonReentrant {\r\n        Offer storage o = offers[ref];\r\n        require(o.paid, \"Not marked paid\");\r\n        require(!o.released, \"Already released\");\r\n        require(whitelist[o.creator] && whitelist[o.counterparty], \"Both must be whitelisted\");\r\n        require(!blacklist[o.creator] && !blacklist[o.counterparty], \"Cannot release to blacklisted user\");\r\n\r\n        uint256 tokenAmount = (o.fiatAmount * o.fiatToTokenRate) / DECIMALS;\r\n        if (!o.isBuy && tokenAmount > 0) {\r\n            _safeTransfer(IERC20(o.token), o.counterparty, tokenAmount);\r\n        }\r\n\r\n        o.released = true;\r\n        emit OfferReleased(ref);\r\n    }\r\n\r\n    // ====== Appeals ======\r\n    function createAppeal(bytes32 ref) external offerExists(ref) whenNotPaused notBlacklisted(msg.sender) onlyWhitelisted(msg.sender) {\r\n        Offer storage o = offers[ref];\r\n        require(msg.sender == o.creator || msg.sender == o.counterparty, \"Only parties\");\r\n        require(!o.appealed, \"Already appealed\");\r\n        o.appealed = true;\r\n        emit AppealCreated(ref, msg.sender);\r\n    }\r\n\r\n    function resolveAppeal(bytes32 ref, bool release) external onlyAdmin offerExists(ref) whenNotPaused nonReentrant {\r\n        Offer storage o = offers[ref];\r\n        require(o.appealed, \"No appeal\");\r\n        o.appealed = false;\r\n\r\n        if (release && !o.released) {\r\n            require(whitelist[o.creator] && whitelist[o.counterparty], \"Both must be whitelisted\");\r\n            require(!blacklist[o.creator] && !blacklist[o.counterparty], \"Cannot release to blacklisted user\");\r\n            uint256 tokenAmount = (o.fiatAmount * o.fiatToTokenRate) / DECIMALS;\r\n            if (!o.isBuy && tokenAmount > 0) {\r\n                _safeTransfer(IERC20(o.token), o.counterparty, tokenAmount);\r\n            }\r\n            o.released = true;\r\n        }\r\n\r\n        emit AppealResolved(ref, release);\r\n    }\r\n\r\n    // Dedicated getter for offers\r\n        function getOffer(bytes32 ref) external view returns (\r\n            address creator,\r\n            address counterparty,\r\n            address token,\r\n            bool isBuy,\r\n            uint32 expiry,\r\n            bytes3 fiatSymbol,\r\n            uint64 fiatAmount,\r\n            uint64 fiatToTokenRate,\r\n            bool appealed,\r\n            bool paid,\r\n            bool released,\r\n            uint256 tokenAmount\r\n        ) {\r\n            Offer storage o = offers[ref];\r\n            uint256 tokenAmount1 = (o.fiatAmount * o.fiatToTokenRate) / DECIMALS;\r\n            return (\r\n                o.creator,\r\n                o.counterparty,\r\n                o.token,\r\n                o.isBuy,\r\n                o.expiry,\r\n                o.fiatSymbol,\r\n                o.fiatAmount,\r\n                o.fiatToTokenRate,\r\n                o.appealed,\r\n                o.paid,\r\n                o.released,\r\n                tokenAmount1 );\r\n        }\r\n}"
      }
    }
  }
}